\section{Θεωρητικό Υπόβαθρο}
\subsection{To μοντέλο Προγραμματισμού \en{OpenMP}}
\subparagraph{}
Το μοντέλο προγραμματισμού του \en{OpenMP} βασίζεται στο πολυνηματικό μοντέλο παραλληλισμού.  Η εφαρμογή ξεκινάει με ένα μόνο νήμα, το κύριο (\en{master thread}), που εκτελεί εντολές σειριακού κώδικα. Το \emph{\en{id}} αυτού του νήματος είναι πάντα μηδέν και η διάρκεια ζωής του είναι μέχρι το πέρας της εκτέλεσης του προγράμματος\cite{pdplab}. 

Όταν το κύριο νήμα  εισέρχεται στην περιοχή παράλληλου κώδικα (\en{parallel region}), τότε δημιουργούνται περισσότερα νήματα και το τμήμα αυτό εκτελείται ταυτόχρονα από τα παραγόμενα νήματα. Με την ολοκλήρωση της εκτέλεσης του παράλληλου τμήματος, όλα τα νήματα που δημιουργήθηκαν τερματίζουν και συνεχίζει μόνο το κύριο, μέχρι να βρεθεί κάποιο άλλο τμήμα παράλληλου κώδικα (\en{fork-join} μοντέλο)\cite{pdplab}. Το κύριο νήμα είναι υπεύθυνο για την δημιουργία των επιπλέον νημάτων για τη συνολική εκτέλεση. Τα νήματα που είναι ενεργά σε μια παράλληλη περιοχή αναφέρονται ως \en{"}ομάδα” (\emph{\en{thread team}}). Πάνω από μία ομάδες νημάτων μπορεί να είναι ενεργές ταυτόχρονα\cite{ompblaise}.

\begin{figure}[h]
\includegraphics[width=\textwidth]{fork_join}
\captionsetup{justification=centering, singlelinecheck=false}
\caption{Κύριο νήμα και ομάδες νημάτων}
\label{fig:fork_join}
\end{figure}

\subsection{Αλληλεπίδραση νημάτων και περιβάλλοντος δεδομένων}
\subparagraph{}
Οπως προαναφέρθηκε, η εκτέλεση του προγράμματος ξεκινάει από το κύριο νήμα. Το νήμα αυτό συσχετίζεται με ένα περιβάλλον δεδομένων. Το περιβάλλον δεδομένων για ένα νήμα είναι ο χώρος διευθύνσεων μνήμης στον οποίο εισάγονται όλες οι μεταβλητές του προγράμματος, περιλαμβανομένων των \emph{καθολικών} μεταβλητών, των μεταβλητών που είναι αποθηκευμένες στη μνήμη \emph{\en{stack}} και αυτών που είναι αποθηκευμένες στη \emph{\en{heap}}\cite{book2}. 

Στο μοντέλο μνήμης του \en{OpenMP}, τα δεδομένα χωρίζονται σε δύο βασικές κατηγορίες μνήμης: στα ιδιωτικά(\emph{\en{private}}) και τα κοινόχρηστα(\emph{\en{shared}}).  Όλα τα νήματα έχουν πρόσβαση χωρίς περιορισμούς σε μεταβλητές που είναι αποθηκευμένες στην κοινόχρηστη μνήμη\cite{thenextstep7}.
\ \\
\begin{center}
\begin{figure}[h]
\includegraphics[width=\textwidth]{private_shared}
\captionsetup{justification=centering, singlelinecheck=false}
\caption{Μοντέλο μνήμης \en{OpenMP}}
\label{fig:private_shared}
\end{figure}
\end{center}
\ \\
\subsubsection{Ιδιωτική μνήμη}
\subparagraph{}
Πρόκειται για τη μνήμη που είναι προσβάσιμη και μπορεί να τροποποιηθεί από ένα μοναδικό νήμα. Τα νήματα δε μπορούν να έχουν πρόσβαση στην ιδιωτική μνήμη των υπόλοιπων νημάτων. Η διάρκεια ζωής μιας μεταβλητής στην ιδιωτική μνήμη είναι περιορισμένη και διαρκεί όσο εκτελείται ο παράλληλος κώδικας. Από προεπιλογή, κάθε ιδιωτική μεταβλητή δεν είναι αρχικοποιείται στην αρχή της παράλληλης περιοχής\cite{thenextstep9}.

\clearpage
\subsubsection{Κοινόχρηστη μνήμη}
\subparagraph{}
Εκτός από την ιδιωτική μνήμη, κάθε νήμα έχει πρόσβαση και σε ένα άλλο είδος μνήμης, την  κοινόχρηστη. Σε αντίθεση με την ιδιωτική, υπάρχει μόνο μία κοινόχρηστη μνήμη κατα τη διάρκεια εκτέλεσης του προγράμματος, και είναι προσπελάσιμη απο όλα τα νήματα. Ετσι, κάθε νήμα έχει την δυνατότητα τροποποίησης οποιασδήποτε μεταβλητής βρίσκεται στη κοινόχρηστη μνήμη.
Η ταυτόχρονη προσπέλαση κοινόχρηστης μνήμης από διαφορετικά νήματα, προκαλεί τα παρακάτω προβλήματα:
\clearpage
\paragraph{\en{Race Condition}}
\begin{center}
	\begin{minipage}[t]{0.45\linewidth}
\ \\
	Το φαινόμενο αυτό εμφανίζεται στις περιπτώσεις όπου μια ρουτίνα χρησιμοποιεί δεδομένα από τη κοινόχρηστη μνήμη. 
Αν η συνάρτηση καλείται παράλληλα, πολλά νήματα ενδέχεται να προσπαθήσουν να τροποποιήσουν ταυτόχρονα την ίδια διεύθυνση μνήμης, μέσω αυτής της ρουτίνας. Το φαινόμενο αυτό ονομάζεται \emph{\en{race condition}} και οδηγεί σε εσφαλμένους υπολογισμούς. Η απλούστερη λύση, ειναι η δημιουργία ιδιωτικού αντίγραφου για κάθε νήμα. Έτσι, πολλά νήματα μπορούν ταυτόχρονα να τροποποιούν δεδομένα που βρίσκονται σε διαφορετικές θέσεις μνήμης γιατί οι μεταβλητές ορίζονται στο ιδιωτικό περιβάλλον δεδομένων του κάθε νήματος.
	\end{minipage}
	\qquad
	\begin{minipage}[t]{0.47\linewidth}
		\selectlanguage{english}
		\begin{lstlisting}[tabsize=2, basicstyle=\small, language=C++, caption={\el{Παράδειγμα κώδικα με} race condition}, frame=tb]
#include <omp.h>

int main(void) {	
	int sum = 0;

	#pragma omp parallel for
	for (int i = 0;  i < 100; ++i) {
		sum += i;		
	}
}
\end{lstlisting}
\selectlanguage{english}
	\end{minipage}
\end{center}
\ \\
\clearpage
\paragraph{\en{False Sharing}}
\subparagraph{}
Το \emph{\en{false sharing}} είναι ένα συχνό πρόβλημα στην παράλληλη επεξεργασία κοινόχρηστης μνήμης. Εμφανίζεται όταν δύο ή περισσότεροι πυρήνες κρατούν αντίγραφο της ίδιας γραμμής προσωρινής μνήμης (\emph{\en{cache}}). 

\begin{figure}[h]
\includegraphics[width=0.5\textwidth]{false_sharing_2}
\centering
\captionsetup{justification=centering, singlelinecheck=false}
	\caption{\en{False sharing (1/3)}}
\label{fig:false_sharing_2}
\end{figure}

\ \\
\begin{wrapfigure}{l}{0.5\textwidth}
	\centering
	\includegraphics[width=0.5\textwidth]{false_sharing_3}
	\captionsetup{justification=centering, singlelinecheck=false}
	\caption{\en{False sharing (2/3)}}
\label{fig:false_sharing_3}
\end{wrapfigure}

Οταν ένα νήμα τροποποιεί μια μεταβλητή, η γραμμή της μνήμης που βρίσκεται η μεταβλητή ακυρώνεται στους υπόλοιπους πυρήνες. Η γραμμή μνήμης θα πρέπει να ακυρωθεί ακόμη και αν ένας πυρήνας μπορεί να μη τροποποιεί τη συγκεκριμένη θέση μνήμης, αλλά να θέλει να τροποποιήσει ένα άλλο δεδομένο που βρίσκεται σε αυτ. 

\clearpage
\begin{wrapfigure}{l}{0.55\textwidth}
	\centering
	\includegraphics[width=0.55\textwidth]{false_sharing_4}
	\captionsetup{justification=centering, singlelinecheck=false}
	\caption{\en{False sharing (3/3)}}
\label{fig:false_sharing_4}
\end{wrapfigure}

Ο δεύτερος πυρήνας θα πρέπει να φορτώσει εκ νέου τη γραμμή μνήμης, προτού αποκτήσει ξανά πρόσβαση στα δεδομένα της. Η προσπέλαση δεδομένων της κοινόχρηστης μνήμης συχνά επηρεάζει την απόδοση του προγράμματος\cite{false_sharing}.
Λύση στο πρόβλημα του \en{false sharing}, αποτελεί η εισαγωγή τεχνητού κενού (\en{padding}) ανάμεσα στα δεδομένα της γραμμής, με σκοπό την τοποθέτησή τους σε ξεχωριστές γραμμές μνήμης.
\clearpage
\subsection{Αναδρομή σε βασικά χαρακτηριστικά του \emph{\en{OpenMP}}}
\subparagraph{}
Στα κεφάλαια που ακολουθούν αναφέρονται επιγραμματικά, βασικές έννοιες και χαρακτηριστικά του \emph{\en{OpenMP}} που εισήχθησαν μέχρι και την έκδοση 2.5 και χρησιμοποιούνται στα υλοποιημένα παραδείγματα των κεφαλαίων που ακολουθούν. Τα χαρακτηριστικά αυτά εμπλουτίστηκαν ή προστέθηκαν νέα στις μετέπειτα εκδόσεις.

\subsubsection{Μοντέλο συνοχής μνήμης}
\subparagraph{}
Για την αποφυγή φαινομένων \emph{\en{race condition}} που οδηγούν σε λανθασμένα αποτελέσματα, απαιτείται συχνά ο συντονισμός πρόσβασης των νημάτων στις μεταβλητές της κοινόχρηστης μνήμης. Ο όρος \emph{"συγχρονισμός"} αναφέρεται σε τέτοιους μηχανισμούς συντονισμού. Οι οδηγίες συγχρονισμού εγγυώνται το διάβασμα της σωστής τιμής μιας μεταβλητής στην κοινόχρηστη μνήμη μετά από οποιαδήποτε ενημέρωσή της. Μηχανισμοί συγχρονισμού ειναι οι εξής\cite{book2_23}:
\selectlanguage{english}
\begin{itemize}
    \item {\#}pragma omp critical 
    \item {\#}pragma omp atomic
    \item {\#}pragma omp barrier 
    \item {\#}pragma omp ordered
    \item {\#}pragma omp flush
\end{itemize}
\selectlanguage{greek}

\subsubsection{Οδηγίες διαμοιρασμού εργασίας}
\subparagraph{}
Η εντολή \emph{\en{{\#}pragma omp parallel}} κατασκευάζει ένα \emph{\en{"SPMD"}} πρόγραμμα (\emph{\en{"Single Program Multiple Data"}}) οπου κάθε νήμα εκτελεί τον ίδιο κώδικα. Ο όρος \emph{"oδηγία διαμοιρασμού εργασίας"} (\emph{\en{worksharing construct}}) χρησιμοποιείται για να περιγραφεί η κατανομή της εκτέλεσης της αντίστοιχης περιοχής μεταξύ των νημάτων μιας ομάδας που συναντά την περιοχή αυτή.

Μια οδηγία διαμοιρασμού εργασίας δεν έχει κανένα εμπόδιο συγχρονισμού("\emph{\en{barrier}}") κατά την είσοδο στον τμήμα παράλληλης περιοχής. Ωστόσο υπάρχει ένα υπονοούμενο εμπόδιο στο τέλος της οδηγίας. Το εμπόδιο μπορεί να αναιρεθεί με τη χρήση της \emph{"φράσης"} \en{(clause)} \emph{\en{nowait}}. Εάν υπάρχει, το πρόγραμμα θα παραλείψει το φράγμα στο τέλος της οδηγίας και τα νήματα που ολοκληρώνουν την περιοχή διαμοιρασμένης εργασίας, προχωρούν κατευθείαν στις επόμενες οδηγίες που ακολουθούν μέσα στη παράλληλη περιοχή\cite{openmpse16}.
\clearpage
\paragraph{Οδηγία διαμοιρασμού εργασίας βρόγχου - \emph{\en{for}}}
\subparagraph{}
Η οδηγία διαμοιρασμού εργασίας βρόγχου καθορίζει ότι οι επαναλήψεις ενός ή περισσότερων βρόχων θα εκτελούνται παράλληλα από μια ομάδα νημάτων. Οι επαναλήψεις διανέμονται στα ήδη υπάρχοντα νήματα της ομάδας νημάτων της παράλληλης περιοχής.
\ \\
\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Σύνταξη οδηγίας διαμοιρασμού εργασίας βρόγχου}} , frame=tlrb]{Name}
#pragma omp for [clause[[,]clause]...] new-line
	for-loops
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\el{Αποδεκτές φράσεις οδηγίας} for} , frame=tlrb]{Name}
private(list)
firstprivate(list)
lastprivate([lastprivate-modifier:]list)
linear(list[:linear-step])
reduction([reduction-modifier,]reduction-identifier : list)
schedule([modifier[, modifier]:]kind[, chunk_size])
collapse(n)
ordered[(n)]
allocate([allocator :]list)
order(concurrent)
\end{lstlisting}
\selectlanguage{greek}


\paragraph{Οδηγία \emph{\en{sections}}}
\subparagraph{}
Η οδηγία \emph{\en{section}} χρησιμοποιείται για τον μη επαναληπτικό διαμοιρασμό εργασίας σε μια παράλληλη περιοχή. Καθορίζει ότι τα εσωκλειώμενα τμήματα κώδικα θα διαμοιραστούν μεταξύ των νημάτων της ομάδας. Μια οδηγία \emph{\en{sections}} μπορεί να περιέχει περισσότερες από μία, ανεξάρτητες οδηγίες \emph{\en{section}}. Κάθε \emph{\en{section}} εκτελείται μια φορά από ένα νήμα της ομάδας και διαφορετικά \emph{\en{sections}} εκτελούνται από διαφορετικά νήματα. Η σύνταξη μιας οδηγίας \emph{\en{sections}} φαίνεται παρακάτω\cite{pdplab}:

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Σύνταξη οδηγίας} sections} , frame=tlrb]{Name}
#pragma omp sections [clause[ [,] clause] ... ] new-line 
   { 
   [#pragma omp section new-line] 
      structured-block 
   [#pragma omp section new-line 
      structured-block] 
   ... 
   }
\end{lstlisting}
\clearpage
\begin{lstlisting}[language=C++, caption={\el{Αποδεκτές φράσεις οδηγίας} sections} , frame=tlrb]{Name}
private(list) 
firstprivate(list) 
lastprivate([ lastprivate-modifier:] list) 
reduction([reduction-modifier ,] reduction-identifier : list) 
allocate([allocator :] list) 
nowait
\end{lstlisting}
\selectlanguage{greek}

\paragraph{Οδηγία \emph{\en{single}}}
\subparagraph{}
Η οδηγία \emph{\en{single}} που βρίσκεται μέσα σε μια περιοχή παράλληλου κώδικα, με μια ομάδα νημάτων ενεργή, καθορίζει ότι το εσωκλειόμενο τμήμα σε αυτή την οδηγία εκτελείται από ένα μόνο νήμα, αλλά όχι απαραίτητα από το κύριο. Τα υπόλοιπα νήματα της ομάδας, παραμένουν αδρανή στο υπονοούμενο φράγμα που βρίσκεται στο τέλος της οδηγίας \emph{\en{single}}, εκτός εάν έχει οριστεί η φράση \emph{\en{nowait}}\cite{openmpse16}.

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Σύνταξη οδηγίας} single} , frame=tlrb]{Name} 
#pragma omp single [clause[ [,] clause] ... ] new-line 
   structured-block
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\el{Αποδεκτές φράσεις οδηγίας} sections} , frame=tlrb]{Name}
private(list) 
firstprivate(list) 
copyprivate(list) 
allocate([allocator :] list) 
nowait
\end{lstlisting}
\selectlanguage{greek}


\paragraph{Οδηγία \emph{\en{flush}}}
\subparagraph{}
Η οδηγία \emph{\en{flush}} προσδιορίζει ένα σημείο στο οποίο ο μεταγλωττιστής διασφάλίζει οτι όλα τα νήματα μιας ομάδας στην παράλληλη περιοχή είναι συγχρονισμένα σχετικά με τις τιμές που υπάρχουν σε συγκεκριμένες μεταβλητές.
Η οδηγία \emph{\en{flush}} υπονοείται στις παρακάτω περιπτώσεις\cite{ibm_flush}:
\begin{itemize}
\item{\emph{\en{pragma omp barrier}}}
\item{Είσοδος και έξοδος στην οδηγία \emph{\en{omp critical}}}
\item{Έξοδος από την οδηγία \emph{\en{omp parallel}}}
\item{Έξοδος από την οδηγία \emph{\en{omp for}}}
\item{Έξοδος από την οδηγία \emph{\en{omp sections}}}
\item{Έξοδος από την οδηγία \emph{\en{omp single}}}
\end{itemize}

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Σύνταξη οδηγίας} flush} , frame=tlrb]{Name} 
#pragma omp flush [memory-order-clause] [(list)] new-line

\end{lstlisting}

\selectlanguage{greek}

\subparagraph{Οδηγία \emph{\en{master}}}
\subparagraph{}
Η οδηγία \emph{\en{master}} καθορίζει μια περιοχή κώδικα της παράλληλης περιοχής που εκτελείται μόνο από το κύριο νήμα.
Στην οδηγία αυτή δεν υπονοείται φράγμα ούτε στην είσοδο αλλά ούτε και στην έξοδο της περιοχής\cite{ibm_master}.


      
      
\subsubsection{Φράσεις - \en{Clauses}}
\subparagraph{}
Δεδομένου οτι το \emph{\en{OpenMP}} είναι ένα μοντέλο προγραμματισμού κοινής μνήμης, οι περισσότερες μεταβλητές στον κώδικα \emph{\en{OpenMP}} είναι ορατές σε όλα τα νήματα από προεπιλογή. Οι ιδιωτικές μεταβλητές χρησιμοποιούνται για να αποφευχθούν φαινόμενα  \emph{\en{race conditions}} και υπάρχει ανάγκη μεταβίβασης τιμών μεταξύ σειριακού κώδικα και παράλληλης περιοχής με συγκεκριμένες ιδιότητες. Η διαχείριση των δεδομένων επιτυγχάνεται με τη χρήση φράσεων \emph{\en{(clauses)}}. 
Εκτός από τη διαχείριση διαμοιρασμού δεδομένων, υπάρχουν και άλλες κατηγορίες φράσεων που χρησιμοποιούνται για την διαχείριση της παραλληλοποίησης μέσω \emph{\en{OpenMP}} και αναφέρονται στις επόμενες παραγράφους.

\paragraph{Φράσεις διαμοιρασμού δεδομένων - \en{Data sharing attribute clauses}}
\subparagraph{}
Οι φράσεις διαμοιρασμού δεδομένων χρησιμοποιούνται σε οδηγίες για να δώσουν στο χρήστη τη δυνατότητα έλεγχου των δεδομένων που χρησιμοποιούνται μέσα στην οδηγία.

\subparagraph{Φράση \emph{\en{shared}}}
\subparagraph{}
Τα δεδομένα που δηλώνονται εκτός μιας παράλληλης περιοχής, κοινόχρηστα σε όλα τα νήματα. Αν η μεταβλητή τροποποιηθεί από ένα νήμα, η αλλαγή θα είναι ορατή σε όλα τα υπόλοιπα νήματα της ομάδας. Οι μεταβλητές με αυτό το χαρακτηριστικό διατηρούν την τιμή τους και μετά την έξοδο από το παράλληλο τμήμα.

\subparagraph{Φράση \emph{\en{private}}}
\subparagraph{}
Τα δεδομένα που δηλώνονται σε μια παράλληλη περιοχή είναι ιδιωτικά για κάθε νήμα. Κάθε νήμα θα έχει ένα τοπικό αντίγραφο της μεταβλητής στην ιδιωτική του μνήμη. Η ιδιωτική μεταβλητή δεν αρχικοποιείται κατα την είσοδο στην οδηγία που φέρει τη φράση \emph{\en{private}} και η τελική του τιμή δεν διατηρείται για χρήση εκτός της παράλληλης περιοχής.

\subparagraph{Φράση \emph{\en{default}}}
\subparagraph{}
Δίνει τη δυνατότητα στο χρήστη να δηλώσει ότι η προεπιλογή για τα δεδομένα σε μια παράλληλη περιοχή θα είναι ή κοινόχρηστα ή \emph{\en{none}} για \en{C} / \en{C}++ ή {\en{firstprivate}}. Η επιλογή \emph{\en{none}} απαιτεί τη δήλωση της κάθε μεταβλητής που χρησιμοποιείται μέσα στην περιοχή παράλληλου κώδικα, ωστε να καθιστάται σαφές αν θα είναι ιδιωτική ή κοινόχρηστη μέσα των φράσεων διαμοιρασμού μνήμης που προαναφέρθηκαν.

\subparagraph{Φράση \emph{\en{firstprivate}}}
\subparagraph{}
Η μόναδική διαφορά της φράσης \emph{\en{firstprivate}} από τη \emph{\en{private}} είναι οτι σε αντίθεση με την \emph{\en{private}}, η μεταβλητή αρχικοποιείται χρησιμοποιώντας την τιμή της μεταβλητής που υπάρχει με το ίδιο όνομα εκτός της παράλληλης περιοχής.

\subparagraph{Φράση \emph{\en{lastprivate}}}
\subparagraph{}
Η μοναδική διαφορά της φράσης \emph{\en{lastprivate}} από την \emph{\en{private}} είναι ότι σε αντιθεση με την τελευταία, η αρχική τιμή ανανεώνεται μετά το πέρας της οδηγίας στην οποία χρησιμοποιήθηκε η συγκεκριμένη φράση. Μια μεταβλητή μπορεί να είναι δηλωμένη ταυτόχρονα και ως \emph{\en{firstprivate}} αλλά και ως \emph{\en{lastprivate}}.

\clearpage
\subparagraph{Φράση \emph{\en{threadprivate}}}
\subparagraph{}
Η φράση \emph{\en{threadprivate}} ορίζει ότι καθολικά αντικείμενα (ή μεταβλητές) μπορούν να γίνουν προσωρινά ιδιωτικά για κάποιο νήμα. Με αυτό τον τρόπο, μπορούν δημιουργηθούν καθολικά αντικείμενα, αλλά να μετατρέψουμε την εμβέλειά τους σε τοπική για κάποιο νήμα. Οι μεταβλητές για τις οποίες ισχύει η φράση \emph{\en{threadprivate}} συνεχίζουν να είναι ιδιωτικές για κάθε νήμα, ακόμα και σε διαφορετικές παράλληλες περιοχές\cite{pdplab}.

\subparagraph{Φράση \emph{\en{reduction}}}
\subparagraph{}
Εκτελεί μία πράξη αναγωγής για κοινόχρηστες μεταβλητές. Οι μεταβλητές που βρίσκονται σε μία παράλληλη περιοχή και υπάρχουν στη λίστα της φράσης \emph{\en{reduction}}, μεταφέρονται σε τοπικά αντίγραφα, ένα για κάθε νήμα. Με την ολοκλήρωση των επαναλήψεων, εφαρμόζεται η πράξη που ορίζεται στο πεδίο \emph{\en{operator}} και το τελικό αποτέλεσμα αποθηκεύεται στην αρχική θέση τους\cite{pdplab}.
\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Σύνταξη οδηγίας διαμοιρασμού εργασίας βρόγχου}} , frame=tlrb]{Name}
 reduction(operator | intrinsic : list):\end{lstlisting}
\selectlanguage{greek} 

\ \\
\paragraph{Φράσεις συγχρονισμού - \emph{\en{Data sharing attribute clauses}}}
\subparagraph{}
Σε αυτή την κατηγορία, ανήκουν οι φράσεις που χρησιμοποιούνται για τον συντονισμό των νημάτων μιας ομάδας και την αποφυγή λανθασμένων υπολογισμών που προκύπτουν από προβλήματα όπως \emph{\en{race conditions}} σε κοινόχρηστα δεδομένα.

\subparagraph{Φράση \emph{\en{critical}}}
\subparagraph{}
Το τμήμα κώδικα παράλληλης περιοχής που περικλείεται σε αυτή τη φράση, εκτελείται μόνο από ένα νήμα κάθε φορά και από όλη την ομάδα νημάτων ταυτόχρονα. Χρησιμοποιείται συχνά για την προστασία κοινόχρηστων δεδομένων και την πρόληψη φαινομένων \emph{\en{race conditions}}.

\subparagraph{Φράση \emph{\en{atomic}}}
\subparagraph{}
H ενημέρωση μνήμης (ανάγνωση-τροποποίηση-εγγραφή) στην οδηγία που ακολουθεί εκτελείται ατομικά. Δεν καθιστά ολόκληρη την έκφραση \emph{\en{atomic}} αλλα μόνο τις εντολές που αφορούν ενημέρωση μνήμης. Ο μεταγλωττιστής μπορεί να χρησιμοποιεί ειδικές οδηγίες \emph{\en{hardware}} για καλύτερη επίδοση από ό,τι όταν χρησιμοποιείται το \emph{\en{critical clause}}.
      
\clearpage
\subparagraph{Φράση \emph{\en{ordered}}}
\subparagraph{}
Οι εντολές που ακολουθούν, εκτελούνται με τη σειρά με την οποία οι επαναλήψεις θα εκτελούνταν αν ο κώδικας ήταν σειριακός.

\subparagraph{Φράση \emph{\en{barrier}}}
\subparagraph{}
Kάθε νήμα περιμένει έως ότου όλα τα άλλα νήματα μιας ομάδας φτάσουν σε αυτό το σημείο. Υπάρχουν οδηγίες, όπως αυτές που χρησιμοποιούνται για διαμοιρασμό εργασιών βρόγχου, που υπονοούν φράγμα συγχρονισμού \emph{\en{barrier}} στο τέλος της εκτέλεσης τους.

\subparagraph{Φράση \emph{\en{nowait}}}
\subparagraph{}
Χρησιμοποιείται για να ορίσει ότι τα νήματα που ολοκληρώνουν τη εργασία τους μπορούν να προχωρήσουν στην εκτέλεση εντολών της παράλληλης περιοχής, χωρίς να περιμένουν να τελειώσουν όλα τα νήματα της ομάδας. Ελλείψει αυτής της φράσης, τα νήματα συγχρονίζονται με \emph{\en{barrier}} στο τέλος της οδηγίας.
\ \\
\ \\
\subparagraph{Φράση \emph{\en{schedule}}}
\subparagraph{}
Χρησιμοποιείται στην οδηγία διαμοιρασμού εργασίας βρόγχου. Οι επαναλήψεις της οδηγίας ανατίθενται στα νήματα σύμφωνα με τον \emph{τύπο} που ορίζεται μέσα στη φράση.
\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Σύνταξη οδηγίας διαμοιρασμού εργασίας βρόγχου}} , frame=tlrb]{Name}
schedule(type, chunk): 
\end{lstlisting}
\selectlanguage{greek}
\clearpage
    •  Οι τρεις τύποι \emph{\en{scheduling}} είναι\cite{jakacorner}:\\
      
\textbf{1. \emph{\en{static}}}:
\subparagraph{}
Οι επαναλήψεις κατανέμονται σε κάθε νήμα πριν την εκτέλεση του βρόγχου και χωρίζονται ισόποσα σε όλα τα νήματα. Η μεταβλητή \emph{\en{chunk}} αποτελεί έναν ακέραιο που ορίζει τον αριθμό των συνεχόμενων επαναλήψεων που θα εκτελέσει κάθε νήμα της ομάδας.

Οταν δεν ορίζεται το όρισμα \emph{\en{chunk}}, ο αριθμός των επαναλήψεων που ορίζεται σε κάθε νήμα είναι ίσως με $$NumberOfIterations / NumberOfThreads$$
\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Παραδείγματα φράσεις} schedule(static)} , frame=tlrb]{Name}
schedule(static):
    Iterations:       
T1| ****************                                                
T2|                 ****************                                
T3|                                 ****************                
T4|                                               ****************

schedule(static, 4): 
    Iterations:
T1| ****            ****            ****            ****            
T2|     ****            ****            ****            ****        
T3|         ****            ****            ****            ****    
T4|             ****            ****            ****            ****


schedule(static, 8):   
    Iterations:
T1| ********                        ********                        
T2|         ********                        ********                
T3|                 ********                        ********        
T4|                         ********                        ********
\end{lstlisting}
\selectlanguage{greek}
\clearpage
\textbf{2. \emph{\en{dynamic}}}: 
\subparagraph{}
Ο τύπος αυτός χρησιμοποιείται όταν από το σύνολο των επαναλήψεων, ένα τμήμα κατανέμεται στα νήματα. Μόλις ένα συγκεκριμένο νήμα ολοκληρώσει την εκχωρημένη επανάληψή του, συνεχίζει παίρνοντας μία από τις επαναλήψεις που απομένουν. Το ακέραιο όρισμα \emph{\en{chunk}} καθορίζει τον αριθμό των συνεχόμενων επαναλήψεων που εκχωρούνται σε ένα νήμα κάθε φορά. Σε περίπτωση που δε δωθεί αριθμός επαναλήψεων, τότε η προεπιλεγμένη τιμή είναι ένα.
\ \\
\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Παραδείγματα φράσης} \emph{schedule(dynamic)} 1/2} , frame=tlrb]{Name}
schedule(dynamic):
    Iterations:       
T1| *   ** **  * * *  *      *  *    **   *  *  * *       *  *   *  
T2|   *       *     *    * *     * *   *    *        * *   *    *   
T3|  *       *    *     * *   *   *     *  *       *  *  *  *  *   *    
T4|    *  *     *    * *    *  *    *    *    ** *  *   *     *   *                 


schedule(dynamic, 1): 
    Iterations:
T1|     *    *     *        *   *    * *  *  *         *  * *  * *  
T2| *  *  *   * *     *  * * *    * *      *   ***  *   *         * 
T3|  *   *  *  *  *    ** *    *      *  *  * *   *  *   *   *  
T4|   *    *     *  **        *  * *    *          *  *    *  * *  *


schedule(dynamic, 4):   
    Iterations:
T1|             ****                    ****                    ****
T2| ****            ****    ****            ****        ****        
T3|     ****            ****    ****            ****        ****    
T4|         ****                    ****            ****             


schedule(dynamic, 8):   
    Iterations:
T1|                 ********                                ********
T2|                         ********        ********                
T3| ********                        ********        ********        
T4|         ********                                                
\end{lstlisting}
\selectlanguage{greek}

\clearpage
\textbf{3. \en{guided}}: 
\subparagraph{}
Ο τύπος αυτός μοιάζει με τον δυναμικό. Οι επαναλήψεις χωρίζονται σε ομάδες. Κάθε νήμα εκτελεί μια ομάδα και στη συνέχεια ζητάει την επόμενη για εκτέλεση. Η διαδικασία συνεχίζεται έως ότου δεν υπάρχουν άλλες επαναλήψεις.

Η διαφορά με το δυναμικό τύπο είναι στο μέγεθος των ομάδων που διαχωρίζονται οι επαναλήψεις. Το μέγεθος είναι ανάλογο των μή εκχωρημένων επαναλήψεων διαιρούμενο με τον αριθμό των νημάτων. Επομένως το μέγεθος των ομάδων σταδιακά μειώνεται. Το ελάχιστο δυνατό μέγεθος των ομάδων ορίζεται από το όρισμα \emph{\en{chunk}} του οποίου η προεπιλεγμένη τιμή είναι 1. Παρόλα αυτά, μόνο η τελευταία ομάδα επαναλήψεων μπορεί να είναι μικρότερη από το \emph{\en{chunk}}.

  \selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Παραδείγματα φράσης} \emph{schedule(guided)}} , frame=tlrb]{Name}
schedule(guided):
    Iterations:       
T1|                             *********                       
T2|                 ************                     *******  ***   
T3|                                      *******                   *
T4| ****************                            *****       **    * 


schedule(guided, 2): 
    Iterations:
T1|                 ************                     ****     **    
T2|                                      *******         ***    **  
T3|                             *********                           
T4| ****************                            *****       **    **


schedule(guided, 4):   
    Iterations:
T1|                                      *******                    
T2|                 ************                     ****    ****   
T3|                             *********                           
T4| ****************                            *****    ****    ***


schedule(guided, 8):   
    Iterations:
T1|                 ************                 ********        ***
T2| ****************                                                
T3|                                      ********                   
T4|                             *********                ********
\end{lstlisting}
\selectlanguage{greek}
     
       
       \begin{figure}[h]
\includegraphics[width=\textwidth]{schedules}
\centering
\captionsetup{justification=centering, singlelinecheck=false}
	\caption{Τύποι φράσης \en{Schedule}}
\label{fig:schedules}
\end{figure}


\subsubsection{Μεταβλητές Περιβάλλοντος}
\subparagraph{}
Αυτή η παράγραφος αναφέρεται επιγραμματικά στις μεταβλητές περιβάλλοντος που καθορίζουν τις ρυθμίσεις των \emph{\en{ICV (Internal Control Variables)}} που επηρεάζουν την εκτέλεση των προγραμμάτων. Τα ονόματα των μεταβλητών περιβάλλοντος πρέπει να είναι κεφαλαία. Η τροποποίηση των μεταβλητών κατά τη διάρκεια εκτέλεσης του προγράμματος δεν είναι εφικτή, και αγνοείται απο το \emph{\en{OpenMP}}. Παρόλα αυτά, μερικές μπορούν να τροποποιηθούν κατα την εκτέλεση μέσω της χρήσης των αντίστοιχων οδηγίων της διεπαφής\cite{environmental_var}.

\begin{table}[htbp]
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{Πίνακας μεταβλητών περιβάλλοντος.}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.5\textwidth} | p{0.5\textwidth}|}

\emph{\en{OMP\_SCHEDULE}} & \emph{\en{OMP\_NUM\_THREADS}} \\
\hline
 \emph{\en{OMP\_DYNAMIC}} & \emph{\en{OMP\_PROC\_BIND}}\\
\hline
 \emph{\en{OMP\_WAIT\_POLICY}} & \emph{\en{OMP\_NESTED}} \\
\hline
\emph{\en{OMP\_THREAD\_LIMIT}} & \emph{\en{OMP\_MAX\_ACTIVE\_LEVELS}} \\
\hline
\emph{\en{OMP\_CANCELLATION}} & \emph{\en{OMP\_DISPLAY\_ENV}} \\
\hline
\emph{\en{OMP\_DISPLAY\_AFFINITY}} & \emph{\en{OMP\_AFFINITY\_FORMAT}} \\
\hline
\emph{\en{OMP\_DEFAULT\_DEVICE}} & \emph{\en{OMP\_MAX\_TASK\_PRIORITY}} \\
\hline
\emph{\en{OMP\_TARGET\_OFFLOAD}} & \emph{\en{OMP\_TOOL}} \\
\hline
\emph{\en{OMP\_TOOL\_LIBRARIES}} & \emph{\en{OMP\_DEBUG}} \\
\hline
\emph{\en{OMP\_ALLOCATORS}} &  \\
\hline
\end{tabular}
\end{table}


\subsubsection{\emph{\en{Runtime Functions}}}
\subparagraph{}

Σκοπός της παρούσας παραγράφου είναι η περιληπτική περιγραφή των ενσωματωμένων ρουτίνων της βιβλιοθήκης \emph{\en{OpenMP}}, για λόγους πληρότητας κειμένου.
Η κεφαλίδα \emph{\en{<omp.h>}}, περιλαμβάνει ένα σύνολο ρουτίνων που χωρίζονται σε τρεις μεγάλες κατηγορίες: Τις ρουτίνες ελέγχου περιβάλλοντος εκτέλεσης που χρησιμοποιούνται για τον συντονισμό των νημάτων και της εκτέλεσης της παράλληλης περιοχής, τις ρουτίνες κλειδώματος τον νημάτων που χρησιμοποιούνται για τον συγχρονισμό της πρόσβασης των δεδομένων, τις ρουτίνες καταμέτρησης χρόνου.
\ \\

\begin{table}[htbp]
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{Πίνακας ενσωματωμένων ρουτίνων}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.5\textwidth} | p{0.5\textwidth}|}
\hline
\textbf{Ρουτίνες περιβάλλοντος εκτέλεσης} \cellcolor[HTML]{D0D0D0} & \textbf{Ρουτίνες κλειδώματος} \cellcolor[HTML]{D0D0D0} \\
\hline
 \emph{\en{omp\_set\_num\_threads}} & \emph{\en{omp\_init\_lock}} \\
\hline
\emph{\en{omp\_get\_num\_threads}}  & \emph{\en{omp\_destroy\_lock}} \\
\hline
\emph{\en{omp\_get\_max\_threads}}  &  \emph{\en{omp\_set\_lock}}\\
\hline
\emph{\en{omp\_get\_thread\_num}} &  \emph{\en{omp\_unset\_lock}}\\
\hline
 \emph{\en{omp\_get\_num\_procs}} & \emph{\en{omp\_test\_lock}} \\
\hline
\emph{\en{omp\_in\_parallel}}     & \emph{\en{omp\_init\_nest\_lock}}\\
\hline
 \emph{\en{omp\_set\_dynamic}}    & \emph{\en{omp\_destroy\_nest\_lock}} \\
\hline
 \emph{\en{omp\_get\_dynamic}}    & \emph{\en{omp\_set\_nest\_lock}} \\
\hline
 \emph{\en{omp\_set\_nested}}     &  \emph{\en{omp\_unset\_nest\_lock}}\\
\hline

\hline
      \multicolumn{2}{|c|}{\textbf{Ρουτίνες καταμέτρησης χρόνου}  \cellcolor[HTML]{D0D0D0}}\\
 \hline
\emph{\en{omp\_get\_wtime }}    & \emph{\en{omp\_get\_wtick }} \\
\hline
\end{tabular}
\end{table}



