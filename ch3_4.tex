\clearpage
\subsection{Ετερογενής Αρχιτεκτονική}
Η ετερογενής αρχιτεκτονική είναι ένα σύνολο προδιαγραφών που επιτρέπουν την ενσωμάτωση κεντρικών μονάδων επεξεργασίας\textbf{\en{(CPU)}} και μονάδων επεξεργασίας γραφικών (και άλλων τύπων επιταχυντών) στον ίδιο δίαυλο, με κοινόχρηστη μνήμη και
εργασίες\cite{toms_hardware}.

Παρόλο που οι \en{GPU} λειτουργούν σε χαμηλότερες συχνότητες, έχουν συνήθως περισσότερους πυρήνες από τις \en{CPU}. Έτσι, μπορούν να επεξεργαστούν περισσότερες εικόνες και γραφικά δεδομένα ανα δευτερόλεπτο από μια παραδοσιακή \en{CPU}. Η μετεγκατάσταση των δεδομένων σε μορφη γραφικών και στη συνέχεια η χρήση της \en{GPU} για σάρωση και ανάλυση μπορεί να αυξήσει εκθετικά την επιτάχυνση. Η αύξηση της δημοτικότητας των ετερογενών αρχιτεκτονικών σε όλους τους τύπους υπολογιστών είχε
αξιοσημείωτο αντίκτυπο στην ανάπτυξη λογισμικών υψηλών προδιαγραφών.

Για την εκμετάλλευση των ετερογενών συστημάτων, οι χρήστες πρέπει να κατασκευάζουν λογισμικό που εκτελεί υπολογισμούς σε
διαφορετικές συσκευές. Σε αυτούς τους υπολογισμούς περιλαμβάνονται οι βρόγχοι επανάληψης, που χρησιμοποιούνται ευρέως
στην ανάπτυξη λογισμικών.

Ωστόσο, τα μοντέλα προγραμματισμού για ετερογενή συστήματα είναι δύσκολο να χρησιμοποιηθούν λόγω της αυξημένης δυσκολίας
διαχείρισής τους. Συνήθως, τμήματα κώδικα γράφονται σε δύο εκδόσεις, μία φορά για τον επεξεργαστή γενικού σκοπού και μια
για τον επιταχυντή. Η συντήρηση και ανάπτυξη διπλού
κώδικα, αποτελεί ένα από τα μεγαλύτερα προβλήματα στη διαδικασία του προγραμματισμού.

Για τις ανάγκες διευκόλυνσης, το \emph{\en{OpenMP}} επέκτεινε τις λειτουργίες του με σκοπό την υποστήριξη και ευρεία
χρήση τέτοιων τύπων συστημάτων\cite{barbara}. Τα αποτελέσματα της εργασίας αρχικά δημοσιεύτηκαν στην έκδοση 4.0 και
εξελίχθηκαν περαιτέρω στην έκδοση 4.5. Οι χρήστες μπορούν πλέον να χρησιμοποιήσουν τη διεπαφή για τη δημιουργία
λογισμικών γραμμένων σε γλώσσες προγραμματισμού υψηλότερου επιπέδου και εκτελέσιμων από συσκευές επεξεργασίας γραφικών.
Έτσι επιτυγχάνεται η διατήρηση μίας μόνο έκδοσης του κώδικα, η οποία μπορεί να τρέξει είτε σε μονάδα επεξεργασίας
γραφικών ή σε επεξεργαστή γενικής χρήσης(\emph{\en{CPU}}).
\clearpage
Με τον όρο συσκευή στόχου, εννοείται ένας υπολογιστικός πόρος στον οποίο μπορεί να εκτελεστεί μια περιοχή κώδικα.
Παραδείγματα τέτοιων συσκευών είναι οι \emph{\en{GPU, CPU, DSP, FPGA}} κ.α. Οι συσκευές στόχου έχουν τα δικά τους νήματα,
των οποίων η μετεγκατάσταση σε άλλες συσκευές δεν είναι δυνατή. Η εκτέλεση του προγράμματος ξεκινάει από την κεντρική
συσκευή (\emph{\en{host device}}). Η κεντρική συσκευή είναι υπεύθυνη για την μεταφορά του κώδικα και των δεδομένων
στη συσκευή στόχου (επιταχυντή).

\selectlanguage{english}
\begin{spacing}{1.4}
\begin{lstlisting}[language=C++, caption={\el{Εκτέλεση κώδικα στη συσκευή στόχου}} , frame=tb]{Name}
 void add_arrays(double *A, double *B, double *C, size_t size) {
     size_t i = 0;
 #pragma omp target map(A, B, C)
     for (i = 0; i < size; ++i) {
             C[i] = A[i] + B[i];
     }
 }
\end{lstlisting}
\end{spacing}
\selectlanguage{greek}

Όπως δείχνει το παραπάνω παράδειγμα, ένα νήμα της κύριας συσκευής(\emph{\en{host}}) συναντάει την οδηγία
\emph{\en{\textbf{target}}}. To τμήμα κώδικα που ακολουθεί μεταφέρεται και εκτελείται στη συσκευή στόχου, αν
αυτός υπάρχει. Από προεπιλογή, το νήμα που συναντά την οδηγία περιμένει την ολοκλήρωση της εκτέλεσης της παράλληλης
περιοχής προτού συνεχίσει.

Πριν ένα καινούργιο νήμα που βρίσκεται στη συσκευή στόχου αρχίσει να εκτελεί την περιοχή που περικλείεται στην οδηγία
\emph{\en{target}}, οι μεταβλητές \emph{\en{A, B, C}} απεικονίζονται(\emph{\en{map}} στον επιταχυντή. Η φράση
\emph{\en{map}} είναι το εργαλείο που χρησιμοποιεί το \emph{\en{OpenMP}} για να εξασφαλίσει την πρόσβαση της
συσκευής στόχου στις μεταβλητές αυτές.


\subsubsection{Το αρχικό νήμα της συσκευής στόχου}
Το νήμα που ξεκινάει την εκτέλεση ενός προγράμματος ονομάζεται κύριο νήμα και ανήκει πάντα στην κεντρική συσκευή. Με
άλλα λόγια, ένα πρόγραμμα σε μια αρχιτεκτονική ετερογενούς προγραμματισμού δε ξεκινάει ποτέ από τη συσκευή στόχου.
\clearpage
Με την εισαγωγή της οδηγίας \textbf{\en{target}} στο \emph{\en{OpenMP}} 4.0, πολλαπλά αρχικά νήματα μπορούν να
δημιουργηθούν κατά τη διάρκεια εκτέλεσης ενός προγράμματος. Την εκτέλεση του τμήματος κώδικα στη συσκευή στόχου, την
αναλαμβάνει ένα νέο αρχικό νήμα και όχι το νήμα που συνάντησε την οδηγία \emph{\en{target}}. Το νήμα αυτό μπορεί να
συναντήσει οδηγίες παραλληλισμού και να δημιουργήσει υποομάδες νημάτων. \ \\
\begin{figure}[h]
\includegraphics[width=\textwidth]{heter_1}
\centering
\captionsetup{justification=centering, singlelinecheck=false}
	\caption{Διάγραμμα ομάδων νημάτων σε ετερογενή αρχιτεκτονική}
\label{fig:heter_1}
\end{figure}


\subsubsection{Μοντέλο μνήμης ετερογενούς αρχιτεκτονικής}
Στις επόμενες παραγράφους, ακολουθεί μια περιγραφή του μοντέλου μνήμης της ετερογενούς αρχιτεκτονικής, περιγράφονται έννοιες που σχετίζονται με τις μεταβλητές και η γνώση του θεωρητικού υπόβαθρου καθίσταται απαραίτητη για την ορθή υλοποίηση προγραμμάτων σε τέτοιες αρχιτεκτονικές.
\clearpage
\paragraph{Η οδηγία \emph{\en{map}}}
\ \\
\selectlanguage{english}
\begin{spacing}{0.8}
\begin{lstlisting}[language=C++, caption={\el{Σύνταξη οδηγίας} map} , frame=tlrb]{Name}
map ([[map-type-modifier[,}} map-type:} list)
\end{lstlisting}
\end{spacing}
\selectlanguage{greek}

\selectlanguage{english}
\begin{spacing}{0.8}
\begin{lstlisting}[language=C++, caption={\el{Φράσεις} map} , frame=tlrb]{Name}
alloc
to
from
tofrom -> default
release
delete
\end{lstlisting}
\end{spacing}
\selectlanguage{greek}

Όπως τα νήματα των κύριων συσκευών, έτσι και τα νήματα που δημιουργούνται στις συσκευές στόχου μπορούν να έχουν ιδιωτικές μεταβλητές. Αντίγραφα μεταβλητών στη συσκευή στόχου με χαρακτηριστικό ιδιωτικής μνήμης, δημιουργούνται όταν η οδηγία \emph{\en{target}} ακολουθείται από τη φράση \emph{\en{private} ή \en{firstprivate}}.

Στις αρχιτεκτονικές ετερογενούς προγραμματισμού και σε επίπεδο υλικού, η κύρια συσκευή με τον επιταχυντή μπορεί να μοιράζονται κοινόχρηστη φυσική μνήμη.
Η φράση \emph{\en{map}} χρησιμοποιείται για την αντιστοίχιση δεδομένων ανάμεσα στις δύο συσκευές, αποκρύπτοντας παράλληλα χαρακτηριστικά της φυσικής υλοποίησης. Για παράδειγμα, όταν οι δυο συσκευές δεν έχουν κοινόχρηστη φυσική μνήμη, η μεταβλητή αντιγράφεται στον επιταχυντή. Αντίθετα, στην περίπτωση της υλοποίησης με κοινόχρηστη μνήμη, δεν απαιτείται δημιουργία αντίγραφου.  Η φράση \emph{\en{map}} απαλλάσσει τον χρήστη από τον έλεγχο των χαρακτηριστικών της υλοποίησης σε επίπεδο υλικού, και η διεπαφή ενεργεί ανάλογα με την αρχιτεκτονική που χρησιμοποιείται.
\\
\begin{table}[htbp]
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{Ενέργειες κατά την απεικόνιση μνήμης}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.25\textwidth} | p{0.2\textwidth}|  p{0.2\textwidth} |  p{0.25\textwidth}|}
\hline
\cellcolor[HTML]{D0D0D0} & \textbf{\en{memory allocation}} \cellcolor[HTML]{D0D0D0} & \textbf{\en{copy}}\cellcolor[HTML]{D0D0D0} & \textbf{\en{flush}} \cellcolor[HTML]{D0D0D0} \\
\hline
\textbf{Απεικονισμένη Μνήμη} & Ναι & Ναι & Ναι \\
\hline
\textbf{Διαμοιρασμένη Mνήμη} & Όχι & Όχι & Ναι \\
\hline
\end{tabular}
\end{table}
\clearpage

Η αντιστοίχιση μεταβλητών στον επιταχυντή, χωρίζεται σε τρεις φάσεις:
\begin{enumerate}
  \item Η φάση εισόδου(\emph{\en{map-enter}}) στην αρχή της εκτέλεσης της οδηγίας \emph{\en{target}}, όπου η μεταβλητή απεικονίζεται στον επιταχυντή. Σε αυτή, δεσμεύεται μνήμη του επιταχυντή για την αποθήκευση της μεταβλητής και αντιγράφεται από την κύρια συσκευή.
  \item Η φάση υπολογισμού, που προκύπτει όταν κατά τη διάρκεια εκτέλεσης της παράλληλης περιοχής, τα νήματα που εκτελούν το πρόγραμμα αποκτούν πρόσβαση στην απεικονισμένη μεταβλητή.
  \item Η φάση εξόδου όπου ολοκληρώνεται η αντιστοίχιση των μεταβλητών στον επιταχυντή. Η τιμή της μεταβλητής στον επιταχυντή αντιγράφεται στην αντίστοιχη θέση της κύριας συσκευής. Η δεσμευμένη μνήμη του επιταχυντή ελευθερώνεται.
\end{enumerate}

Οι φάσεις \textbf{1} και \textbf{3} διαχειρίζονται την αποθήκευση και την αντιγραφή των μεταβλητών ανάμεσα σε δυο συσκευές. Ο τύπος της αντιστοίχισης επηρεάζει την αντιγραφή μεταβλητών στον επιταχυντή ή την κύρια συσκευή. Ο καθορισμός του τύπου αντιστοίχισης επηρεάζει την απόδοση του κώδικα.
\begin{centering}
\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{Απαιτούμενη αντιγραφή για κάθε τύπο μεταβλητής κατά τις φάσεις εισόδου-εξόδου}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.25\textwidth} | p{0.25\textwidth}|  p{0.25\textwidth} |  p{0.25\textwidth}|}
 \en{map-type}\cellcolor[HTML]{D0D0D0} & \textbf{Είσοδος} \cellcolor[HTML]{D0D0D0} & \textbf{Έξοδος}\cellcolor[HTML]{D0D0D0} \\
\hline
\textbf{\en{alloc}} & Όχι & Όχι \\
\hline
\textbf{\en{to}} & Ναι & Όχι \\
\hline
\textbf{\en{from}} & Όχι & Ναι \\
\hline
\textbf{\en{tofrom}} & Ναι & Ναι \\
\hline
\textbf{\en{release}} & - & Όχι \\
\hline
\textbf{\en{delete}} & - & Όχι \\
\hline
\end{tabular}
\end{table}
\end{centering}
\clearpage

\selectlanguage{english}
\begin{spacing}{1.1}
\begin{lstlisting}[language=C++, caption={\el{Παράδειγμα χρήσης τύπου αντιστοίχισης μεταβλητών}} , frame=tb]{Name}
void foo(double A[1024], double B[1024], double C[1024) {
	#pragma omp target map(from : A) map(to: B) 
			map(alloc: C) // map enter
	{ ... } // map exit
}
\end{lstlisting}
\end{spacing}
\selectlanguage{greek}

Στο προηγούμενο παράδειγμα:

Η μεταβλητή \textbf{Α}:
\setlist[1]{itemsep=-10pt}

\begin{itemize}
  \item Δεν αρχικοποιείται στον επιταχυντή.
  \item Η τιμή της αντιγράφεται στην κύρια συσκευή.
  \item Η μνήμη αποδεσμεύεται κατά την επιστροφή στην κύρια συσκευή.
\end{itemize}

Η μεταβλητή \textbf{Β}:
\setlist[1]{itemsep=-10pt}

\begin{itemize}
  \item Η τιμή της αντιγράφεται στον επιταχυντή.
  \item Η μνήμη αποδεσμεύεται κατά την επιστροφή στην κύρια συσκευή.
\end{itemize}

Η μεταβλητή \textbf{\en{C}}:
\setlist[1]{itemsep=-10pt}

\begin{itemize}
  \item Η τιμή της αντιγράφεται στον επιταχυντή.
  \item Η μνήμη αποδεσμεύεται κατά την επιστροφή στην κύρια συσκευή.
\end{itemize}

\paragraph{Περιβάλλον δεδομένων συσκευής}
\ \\
Κάθε επιταχυντής έχει ένα περιβάλλον μνήμης στο οποίο περιέχεται το σύνολο των μεταβλητών που είναι προσβάσιμες από νήματα που ενεργούν σε αυτή τη συσκευή. Η οδηγία \emph{\en{map}} διασφαλίζει ότι η μεταβλητή μεταφέρεται από την κύρια συσκευή, στο περιβάλλον δεδομένων του επιταχυντή και είναι προσβάσιμη από αυτόν.

Ανάλογα με την αρχιτεκτονική και τη διαθεσιμότητα κοινόχρηστης μνήμης μεταξύ της κύριας συσκευής\emph{\en{(host)}} και της συσκευής στόχου, η πρωτότυπη μεταβλητή που δημιουργήθηκε στην κύρια συσκευή και η αντίστοιχη της συσκευής στόχου είναι είτε η ίδια μεταβλητή που βρίσκεται στη κοινόχρηστη μνήμη των δυο συσκευών ή αντίγραφα σε διαφορετικές θέσεις μνήμης. Στη δεύτερη περίπτωση, απαιτούνται εργασίες αντιγραφής και ενημέρωσης για να διατηρηθεί η συνέπεια μεταξύ των δυο θέσεων.

Η βελτιστοποίηση της ποσότητας της μεταφοράς δεδομένων ανάμεσα στις δυο συσκευές, αποτελεί κρίσιμο σημείο για την επίτευξη καλύτερης απόδοσης στις ετερογενείς αρχιτεκτονικές.
Η συνεχής αντιστοίχιση μεταβλητών που επαναχρησιμοποιούνται είναι αναποτελεσματική και οδηγεί σε πτώση της απόδοσης.

\paragraph{Δείκτες μεταβλητών συσκευής}
\ \\
Αν η κύρια συσκευή και ο επιταχυντής δεν μοιράζονται την κοινόχρηστη μνήμη, οι τοπικές μεταβλητές τους βρίσκονται σε διαφορετικές θέσεις μνήμης. Όταν μια μεταβλητή απεικονίζεται στο περιβάλλον δεδομένων ενός επιταχυντή, γίνεται μια αντιγραφή και η καινούργια μεταβλητή είναι διαφορετική από την μεταβλητή της κύριας συσκευής.

Οι διευθύνσεις μνήμης αποθηκεύονται σε μεταβλητές που ονομάζονται δείκτες (\emph{\en{pointers}}). Ένα νήμα της κύριας συσκευής δε μπορεί να έχει πρόσβαση σε μνήμη μέσω ενός δείκτη που περιέχει διεύθυνση μνήμης του επιταχυντή. Ακόμη, ο επιταχυντής και η κύρια συσκευή μπορεί να έχουν διαφορετική αρχιτεκτονική, δηλαδή ένας τύπος μεταβλητής μπορεί να είναι διαφορετικού μεγέθους ανάμεσα στις δύο συσκευές.

Ο δείκτης συσκευής \emph{\en{(device pointer)}} είναι ένας δείκτης που αποθηκεύεται στη κύρια συσκευή και περιέχει την διεύθυνση μνήμης στο περιβάλλον δεδομένων του επιταχυντή. Το \emph{\en{OpenMP}} παρέχει ρουτίνες και οδηγίες που καθιστούν εφικτή τη δέσμευση μνήμης στο περιβάλλον του επιταχυντή μέσω της κύριας συσκευής, όπως φαίνεται στο παρακάτω παράδειγμα:


\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={omp\_target\_alloc} , frame=tb]{Name}
int device = omp_get_default_device();
char *device_ptr = omp_target_alloc(n, device);
#pragma omp target is_device_ptr (device_ptr)
for (int j=0; j<n ; j++)
	*device_ptr++ = 0;
\end{lstlisting}
\selectlanguage{greek}
\clearpage


\subsubsection{Η οδηγία \en{target}}
Σκοπός της οδηγίας \emph{\en{target}} είναι η μεταφορά και εκτέλεση ενός τμήματος κώδικα στον επιταχυντή. Η εκτέλεση γίνεται από ένα αρχικό νήμα στη συσκευή. Σε περίπτωση έλλειψης επιταχυντή στο σύστημα, ο κώδικας που προορίζεται να εκτελεστεί εκεί μέσω της οδηγίας \emph{\en{target}} θα εκτελεστεί στην κύρια συσκευή αγνοώντας τις οδηγίες \emph{\en{\#pragma}}.

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Σύνταξη οδηγίας} target} , frame=tlrb]{Name}
#pragma omp target [clause[[,] clause]...]
\end{lstlisting}
\selectlanguage{greek}

\selectlanguage{english}
\begin{spacing}{0,6}
\begin{lstlisting}[showstringspaces=false, language=C++, caption={\el{Παράδειγμα εκτέλεσης στον επιταχυντή} } , frame=tb]{Name}
void test() {
	int flag = 0;
	#pragma omp target map(flag)
	{
		flag = !omp_is_initial_device() ? 1 : 2;
	}
	if (flag == 1) {
		printf("Running on accelerator\n");
	} else if (flag == 2) {
		printf("Running on host\n");
	}
}
\end{lstlisting}
\end{spacing}
\selectlanguage{greek}
Η οδηγία \emph{\en{target}} δημιουργεί μια εργασία που εκτελείται στον επιταχυντή. Η εργασία για την κύρια συσκευή
ολοκληρώνεται όταν ολοκληρωθεί η εκτέλεση στον επιταχυντή. Οι φράσεις \emph{\en{nowait}} και \emph{\en{depend}}
επηρεάζουν τον τύπο και την ασύγχρονη συμπεριφορά της εργασίας. Από προεπιλογή, η εργασία στόχου περιλαμβάνει φράγμα
εκτέλεσης στο τέλος της. Το νήμα που τη συναντά περιμένει μέχρι την ολοκλήρωση της εκτέλεσής της.

Οι δείκτες μεταβλητών που εισάγονται στη φράση \emph{\en{map}}, είναι ιδιωτικές (\emph{\en{private}}) μέσα στη συσκευή
στόχου. Οι ιδιωτικές μεταβλητές δείκτη διεύθυνσης αρχικοποιούνται με την τιμή της διεύθυνσης του επιταχυντή. Οι φράσεις που υποστηρίζονται από την οδηγία είναι:

\selectlanguage{english}
\begin{spacing}{0.9}
\begin{lstlisting}[language=C++, caption={\el{Φράσεις οδηγίας} \emph{\en{target}} } , frame=tlrb]{Name}
if (/target:] scalar-expression)
map ([[map-type-modifier[, map-type:] list]
device (integer-expression)
private (list)
firstprivate (list)
is_device_ptr (list)
defaultmap( tofrom:scalar)
nowait
depend(dependence-type: list)
\end{lstlisting}
\end{spacing}
\selectlanguage{greek}

\subsubsection{Η οδηγία \en{target teams}}
Η οδηγία \emph{\en{target teams}} κατασκευάζει ομάδες νημάτων (\emph{\en{league}}) που λειτουργούν σε έναν επιταχυντή. Η κάθε ομάδα αποτελείται αρχικά από ένα νήμα. Η λειτουργία αυτή είναι παρόμοια με μια οδηγία \emph{\en{parallel}} με τη διαφορά ότι σε αυτή την περίπτωση δημιουργούνται ομάδες που αρχικά αποτελούνται από ένα νήμα και στη συνέχεια τα νήματα της ομάδας πολλαπλασιάζονται. Νήματα διαφορετικών ομάδων δε συγχρονίζονται μεταξύ τους.

Όταν ένα νήμα συναντά μια οδηγία \en{teams}, δημιουργείται ένα σύνολο υποομάδων οπου κάθε υποομάδα αποτελείται από ένα ή περισσότερο νήματα. Αυτή η δομή χρησιμοποιείται για να εκφράζεται ένας τύπος χαλαρού παραλληλισμού, όπου ομάδες νημάτων εκτελούν παράλληλα, αλλά με μικρή αλληλεπίδραση μεταξύ τους.


\selectlanguage{english}
\begin{spacing}{1.0}
\begin{lstlisting}[language=C++, caption={\el{Φράσεις οδηγίας } \emph{\en{target teams}} } , frame=tlrb]{Name}
num_teams (integer-expression)
threadJimit (integer-expression)
default(shared I none)
private (list)
firstprivate (list)
shared (list)
reduction (reduction-identifier : list)
\end{lstlisting}
\end{spacing}
\selectlanguage{greek}
\subsubsection{Η οδηγία \en{distribute}}

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Σύνταξη οδηγίας} \emph{\en{distribute}} } , frame=tlrb]{Name}
#pragma omp distribute {clause[[,} clause}. . . j
	for-loops
\end{lstlisting}
\selectlanguage{greek}


\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Φράσεις υποστηριζόμενες από την οδηγία} \emph{\en{distribute}} } , frame=tlrb]{Name}
private {list)
firstprivate {list)
lastprivate {list)
collapse (n)
dist_schedule {kind[, chunk_sizej)
\end{lstlisting}
\selectlanguage{greek}
\clearpage

Η οδηγία \emph{\en{distribute}} χρησιμοποιείται για τον δήλωση διαμοιρασμού των επαναλήψεων ενός βρόγχου στα αρχικά νήματα των ομάδων που δημιουργήθηκαν από την οδηγία \emph{\en{target teams}}. Η οδηγία δεν περιλαμβάνει υπονοούμενο φράγμα εργασιών στο τέλος της, πράγμα που σημαίνει ότι τα κύρια νήματα των ομάδων δε συγχρονίζονται στο τέλος της οδηγίας.

Η φράση \emph{\en{dist\_schedule}} καθορίζει τον τρόπο που διαμοιράζονται οι επαναλήψεις σε τμήματα. Συγκριτικά με την οδηγία \emph{\en{for}}, η \emph{\en{distribute}} έχει πιθανότητες για καλύτερη απόδοση καθώς ο μεταγλωττιστής μπορεί να πετύχει καλύτερο επίπεδο βελτιστοποίησης.



\subsubsection{Σύνθετες οδηγίες επιταχυντών}
Οι συνδυασμένες οδηγίες είναι ισοδύναμες με τις επιμέρους  οδηγίες από τις οποίες αποτελούνται. Για παράδειγμα, η οδηγία \emph{\en{parallel for}} έχει την ίδια σημασία με την \emph{\en{parallel}} ακολουθούμενη από την οδηγία \emph{\en{for}}. Παρόλα αυτά, ορισμένες φορές οι συνδυασμένες οδηγίες μπορούν να επιτύχουν καλύτερες επιδόσεις.
Σε αυτή την παράγραφο, οι οδηγίες χωρίζονται σε δύο κατηγορίες, τις συνδυασμένες με \emph{\en{target}} και αυτές που συνδυάζονται με \emph{\en{target teams}}.
\selectlanguage{english}
\begin{spacing}{1.0}
\begin{lstlisting}[language=C++, caption={\el{Συνδυασμένες οδηγίες συσκευής στόχου}} , frame=tlrb]{Name}
#pragma omp target parallel [clause[[,] clause]...]
	structured blocks
#pragma omp target parallel for [clause[[,] clause]...]
	for-loops	
#pragma omp target parallel for simd [clause[[,] clause]...]
	for-loops
#pragma omp target simd [clause[[,] clause]...]
	for-loops
\end{lstlisting}
\selectlanguage{greek}

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Συνδυασμένες οδηγίες διαμοιρασμού εργασιών στη συσκευή στόχου}} , frame=tlrb]{Name}
#pragma omp distribute parallel for [clause[[,] clause]...]
	for-loops
#pragma omp distribute simd [clause[[,] clause]...]
	for-loops
#pragma omp distribute parallel for simd [clause[[,] clause]...]
	for-loops
\end{lstlisting}
\end{spacing}
\selectlanguage{greek}

\clearpage

\subsubsection{Οδηγία \emph{\en{declare target}}}
Η οδηγία \emph{\en{declare target}} χρησιμοποιείται για συναρτήσεις και μεταβλητές. Μια συνάρτηση που καλείται μέσα στο τμήμα του \emph{\en{target}} κώδικα, θα πρέπει να δηλώνεται στην οδηγία \emph{\en{declare target}}. Ακόμη, η οδηγία χρησιμοποιείται για την αντιστοίχιση καθολικών μεταβλητών στο περιβάλλον δεδομένων του επιταχυντή.

\selectlanguage{english}
\begin{spacing}{1.1}
\begin{lstlisting}[language=C++, caption={\el{Οδηγία} declare target} , frame=tlrb]{Name}
#pragma omp declare target
	declarations-definitions-seq
#pragma omp end declare target
#pragma omp declare target(extended-list)
#pragma omp declare target clause[[l] clause]...]

CLAUSE:
to (extended-list)
link (list)
\end{lstlisting}
\end{spacing}
\selectlanguage{greek}
