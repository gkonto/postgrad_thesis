\setstretch{1.5}
\clearpage
\section{Εισαγωγή}
\subsection{Συνοπτικά για το \en{OpenMP}}
Το \en{OpenMP} είναι μια Διεπαφή Προγραμματισμού Εφαρμογών (\emph{\en{API}}) που χρησιμοποιείται για
παραλληλοποίηση συστημάτων διαμοιραζόμενης μνήμης από λογισμικά γραμμένα σε γλώσσες
\textbf{\en{C/C++}} και \textbf{\en{Fortran}}. Η διεπαφή αποτελείται από τα παρακάτω
σύνολα\cite{thenextstep20}:
\begin{spacing}{1.1}
\begin{itemize}
    \item σύνολο οδηγιών \textbf{\en{(directives)}} για τον μεταγλωττιστή που έχουν ως στόχο τον
    καθορισμό και τον έλεγχο της παραλληλοποίησης.
    \item σύνολο ενσωματωμένων ρουτινών της βιβλιοθήκης \en{OpenMP}.
    \item σύνολο μεταβλητών περιβάλλοντος.
\end{itemize}
\end{spacing}

Οι εντολές παραλληλοποίησης εφαρμόζονται στο τμήμα του κώδικα που ακολουθεί της οδηγίας. Κάθε
κατασκευή ξεκινάει με \textbf{\emph{\en{\#pragma omp}}} ακολουθούμενη από οδηγίες για το
μεταγλωττιστή. Το δομημένο τμήμα κώδικα μπορεί να αποτελείται από μια εντολή ή ένα σύνολο εντολών\cite{ompsyntaxrefguide}. Οι εντολές που βρίσκονται εντός της περιοχής παράλληλου κώδικα,
εκτελούνται από όλα τα νήματα που δημιουργούνται κατά τη διάρκεια της παραλληλοποίησης. Η
παραλληλοποίηση ολοκληρώνεται με το πέρας της εκτέλεσης των εντολών εντός αυτής της περιοχής. \ \\
\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Γραμματική σύνταξης οδηγίας} OpenMP}, frame = single, xleftmargin=.1\textwidth]
#pragma omp (directive) [clause[[,] clause]...] new-line
\end{lstlisting} 
\selectlanguage{greek}
Με τη χρήση του \emph{\en{OpenMP}} οι εφαρμογές εκμεταλλεύονται την ύπαρξη πολλαπλών επεξεργαστικών
μονάδων, με σκοπό την επίτευξη αύξησης των υπολογιστικών επιδόσεων και μείωση του απαιτούμενου
χρόνου εκτέλεσης της εφαρμογής. Ο παράλληλος προγραμματισμός μπορεί να ιδωθεί ως ειδική περίπτωση
ταυτόχρονου προγραμματισμού, όπου η εκτέλεση γίνεται πραγματικά παράλληλα και όχι
ψευδοπαράλληλα, δηλαδή με χρονομερισμό\cite{googleparallelprog}. \ \\
\selectlanguage{english}
\begin{spacing}{1.1}
\begin{lstlisting}[showstringspaces=false, language=C++, caption={\el{Παράδειγμα παράλληλου κώδικα} OpenMP}, frame=tb]
#include <omp.h>    // OpenMP include file
#include <stdio.h>  // Include input-output library

int main(void) {
    #pragma omp parallel 
    {
        int id = omp_get_thread_num();
        std::cout << "Hello " << id;
        std::cout << "world " << std::endl;
    }
}
\end{lstlisting}
\end{spacing}
\selectlanguage{greek}

\subsection{Σκοπός – Στόχοι}
Σκοπός της παρούσας εργασίας είναι η μελέτη της βιβλιογραφίας της διεπαφής του \emph{\en{OpenMP}},
δίνοντας μεγαλύτερη βαρύτητα στις εκδόσεις από 3.0 έως 4.5, στα χαρακτηριστικά και τις δυνατότητες
που εισήχθησαν σε αυτές, καθώς επίσης και στην κατασκευή παραδειγμάτων υλοποίησης αλγορίθμων με αυτά
τα χαρακτηριστικά. Αναλύονται σε θεωρητικό επίπεδο οι οδηγίες και φράσεις (\emph{\en{clauses}})
των νέων εκδόσεων, ενώ γίνεται μια προσπάθεια υλοποίησης και συγκριτικής μελέτης απλών και σύνθετων
προβλημάτων, επιλυμένων με διαφορετικές μεθόδους και παραλλαγές, που βασίζονται στα καινούργια
χαρακτηριστικά της διεπαφής. Στόχος είναι η σαφής κατανόηση των εισαγόμενων χαρακτηριστικών της
διεπαφής στις συγκεκριμένες εκδόσεις, η εξαγωγή συμπερασμάτων μέσα από τις υλοποιήσεις των
προβλημάτων αλλά και η σύγκριση των διαφορετικών μεθόδων επίλυσης κάθε επιμέρους προβλήματος με βάση
τις επιδόσεις τους.

\newpage
\subsection{Διάρθρωση της μελέτης}
Στα επόμενα κεφάλαια γίνεται μια σύντομη περιγραφή του μοντέλου προγραμματισμού της διεπαφής
\emph{\en{OpenMP}} και της αλληλεπίδρασης των παραγόμενων νημάτων με το περιβάλλον δεδομένων.
Στη συνέχεια, γίνεται σύντομη ανασκόπηση σε έννοιες απαραίτητες για την μελέτη των νέων χαρακτηριστικών που
εισήχθησαν στις εκδόσεις μετά την 2.5. Η ανασκόπηση περιορίζεται κυρίως στις οδηγίες και τις
φράσεις που υπάρχουν στις παλαιότερες εκδόσεις της διεπαφής. Ακολουθεί ανάλυση σε
θεωρητικό υπόβαθρο των σημαντικότερων εννοιών που εισήχθησαν στις εκδόσεις 3.0 - 4.5 όπως αυτή των
εργασιών-\emph{\en{Tasking}}, του \emph{\en{offloading}}, της διανυσματικοποίησης
-\emph{\en{vectorization}} κ.α. Αμέσως μετά, ακολουθεί η υλοποίηση, ο σχολιασμός και η συγκριτική
μελέτη απλών και σύνθετων προβλημάτων. Στο τέλος γίνεται η καταγραφή των σημαντικότερων
συμπερασμάτων, εξαγόμενων από τις υλοποιήσεις.