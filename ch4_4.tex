\subsection{Παράδειγμα υπολογισμού $\pi$}
\subparagraph{}
Στο επόμενο παράδειγμα ακολουθεί ο υπολογισμός του αριθμού $\pi$.
Το πρόβλημα ανάγεται στον υπολογισμό του παρακάτω ολοκληρώματος, με τη χρήση αριθμητικών μεθόδων: $$\pi = \int_{0}^{1} \frac{4.0} {(1+x^2)}\, dx$$
που υπολογίζεται αριθμητικά ως:
$$\pi \approx \sum_{k=1}^N F(xi)\Delta x$$ Το πρόβλημα δέχεται ως παράμετρο τον αριθμό των βημάτων της αριθμητικής ολοκλήρωσης. Όσο πιο μεγάλος είναι ο αριθμός των βημάτων, τόσο πιο ακριβής είναι και ο υπολογισμός του $\pi$.

\clearpage
\subsubsection{Σειριακή εκτέλεση}
\subparagraph{}
Η σειριακή υλοποίηση του υπολογισμού $\pi$ με χρήση αριθμητικών μεθόδων, αποτελείται από ένα βρόγχο επανάληψης. Σε κάθε επανάληψη του οποίο υπολογίζεται ένα μικρό τμήμα του συνολικού ολοκληρώματος, το ίχνος του οποίο είναι ίσο με $1/num\_steps$, όπως φαίνεται παρακάτω:

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Υλοποίηση σειριακής έκδοσης υπολογισμού $\pi$}} , frame=tlrb]{Name}
double pi(long num_steps) {
    int upper_limit = 1;
    double step = upper_limit/(double)num_steps;
    double sum = .0, pi = .0;

    for (int i = 0; i < num_steps; ++i)
    {
        double x = (i + 0.5) * step;
        sum += 4.0 / (1.0 + x*x);
    }
    pi = step * sum;
    
    return pi;
}
\end{lstlisting}
\selectlanguage{greek}

\selectlanguage{greek}

\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{ \emph{Καταγραφή χρόνων εκτέλεσης παραδειγμάτων}}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.35\textwidth} | p{0.35\textwidth}|}
 \textbf{Αριθμός Βημάτων\cellcolor[HTML]{D0D0D0}} & \textbf{Χρόνος Υπολογισμού (\emph{\en{sec}}) }\cellcolor[HTML]{D0D0D0} \\
\hline
 100000000 &  2.812\\
\hline
 200000000 &  5.633\\
\hline
 300000000 &  8.469\\
\hline
 400000000 &  11.592  \\
 \hline
\end{tabular}
\end{table}

\paragraph{Σχόλιο:}
\subparagraph{}
Ο συγκεκριμένος αλγόριθμος λόγω του βρόγχου επανάληψης και του αθροίσματος των δεδομένων σε μια μεταβλητή, επιδέχεται πολλών παραλλαγών που υλοποιούνται στις επόμενες παραγράφους.


\clearpage
\subsubsection{Παραλλαγή 1\textsuperscript{η}}
\subparagraph{}
Στη συγκεκριμένη περίπτωση, ο αλγόριθμος παραλληλοποιείται με τη χρήση της οδηγίας \emph{\en{pragma omp parallel}}. Η επαναλήψεις του βρόγχου διαμοιράζονται στα νήματα και τα απότελεσματα των υπολογισμών του κάθε νήματος αποθηκεύονται στη σχετική θέση ενός διανύσματος. Ο τελικός υπολογισμός γίνεται σειριακά, με τη χρήση του διανύσματος αυτού.
\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Υπολογισμός παραλλαγής 1}} , frame=tlrb]{Name}
double pi(long num_steps) {
    int num_threads = omp_get_num_threads(), nthreads = 0;
	double pi = .0;

    double *sum = new double [num_threads];
    for (int i = 0; i < num_threads; ++i) {
        sum[i] = 0.0;
    }
    double step= 1.0/(double)num_steps;
#pragma omp parallel
    {
        int id = omp_get_thread_num();
        int nthrds = omp_get_num_threads();
        if (id == 0) nthreads = nthrds; 
        for (int i = id; i < num_steps; i += nthrds) {
            double x = (i + 0.5)*step;
            sum[id] += 4.0/(1.0 + x*x);
        }
    }

    for (int i = 0; i < nthreads; ++i) {
        pi += sum[i] * step;
    }
    delete []sum;
    return pi;
}

\end{lstlisting}
\selectlanguage{greek}

\selectlanguage{greek}

\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{ \emph{Καταγραφή χρόνων εκτέλεσης παραδειγμάτων}}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.35\textwidth} | p{0.35\textwidth}|}
 \textbf{Αριθμός Βημάτων\cellcolor[HTML]{D0D0D0}} & \textbf{Χρόνος Υπολογισμού (\emph{\en{sec}}) }\cellcolor[HTML]{D0D0D0} \\
\hline
 100000000 & 2.71\\
\hline
 200000000 &   5.41\\
\hline
 300000000 &  8.11\\
\hline
 400000000 &  10.796  \\
 \hline
\end{tabular}
\end{table}

\clearpage
\subsubsection{Παραλλαγή 2\textsuperscript{η}}
\subparagraph{}
Στη δεύτερη παραλλαγή του προβλήματος, χρησιμοποιείται η οδηγία \textbf{\en{\emph{pragma omp critical}}}. Ετσι, διασφαλίζεται η σωστή ανανέωση της μεταβλητής \emph{\en{pi}} που προστατεύεται από φαινόμενα \emph{\en{race condition}}.
\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Υλοποίηση παραλλαγής 2}} , frame=tlrb]{Name}
double pi(long num_steps) {
    int nthreads = 0;
    double pi = .0;
    int num_threads = omp_get_num_threads();
    double step= 1.0/(double)num_steps;
#pragma omp parallel
    {
        int id = omp_get_thread_num();
        int nthrds = omp_get_num_threads();
        double sum = 0.0, x = 0.0;
        if (id == 0) nthreads = nthrds;

        for (int i = id;  i < num_steps; i += nthreads) {
            x = (i + 0.5)*step;
            sum += 4.0/(1.0 + x*x);
        }
#pragma omp critical
        pi += sum * step;
    }
    return pi;
}
\end{lstlisting}
\selectlanguage{greek}
\selectlanguage{greek}

\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{ \emph{Καταγραφή χρόνων εκτέλεσης παραδειγμάτων}}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.35\textwidth} | p{0.35\textwidth}|}
 \textbf{Αριθμός Βημάτων\cellcolor[HTML]{D0D0D0}} & \textbf{Χρόνος Υπολογισμού (\emph{\en{sec}}) }\cellcolor[HTML]{D0D0D0} \\
\hline
 100000000 & 2.89\\
\hline
 200000000 & 5.78 \\
\hline
 300000000 & 8.69\\
\hline
 400000000 & 11.55 \\
 \hline
\end{tabular}
\end{table}
\paragraph{Σχόλιο:}
\subparagraph{}
Η κακή επίδοση του αλγόριθμου, οφείλεται στο γεγονός οτι η οδηγία \emph{\en{pragma omp critical}} επιτρέπει σε ένα νήμα κάθε φορά να ενημερώνει τη μετάβλητή, με αποτέλεσμα τα υπόλοιπα νήματα να αναμένουν την αποδέσμευσή της.

\clearpage
\subsubsection{Παραλλαγή 3\textsuperscript{η}}
\subparagraph{}

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Αρχικοποίηση τιμών διανύσματος}} , frame=tlrb]{Name}
double pi(long num_steps) {
    int nthreads = 0;
    double pi = .0;
    double step= 1.0/(double)num_steps;
#pragma omp parallel
    {
        int id = omp_get_thread_num();
        int nthrds = omp_get_num_threads();
        double sum = 0.0, x = 0.0;

        if (id == 0) nthreads = nthrds;    

        for (int i = id; i < num_steps; i += nthreads) {
            x = (i + 0.5)*step;
            sum += 4.0/(1.0 + x*x);
        }
        sum *= step;
#pragma omp atomic
        pi += sum;
    }

    return pi;
}      
\end{lstlisting}
\selectlanguage{greek}


\selectlanguage{greek}

\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{ \emph{Καταγραφή χρόνων εκτέλεσης παραδειγμάτων}}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.35\textwidth} | p{0.35\textwidth}|}
 \textbf{Αριθμός Βημάτων\cellcolor[HTML]{D0D0D0}} & \textbf{Χρόνος Υπολογισμού (\emph{\en{sec}}) }\cellcolor[HTML]{D0D0D0} \\
\hline
 100000000 & 0.207 \\
\hline
 200000000 & 0.387 \\
\hline
 300000000 & 0.579 \\
\hline
 400000000 & 0.761 \\
 \hline
\end{tabular}
\end{table}

\clearpage
\subsubsection{Παραλλαγή 4\textsuperscript{η}}
\subparagraph{}

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Αρχικοποίηση τιμών διανύσματος}} , frame=tlrb]{Name}
    double pi(long num_steps, int num_threads) {
    double pi = .0;
    double step= 1.0/(double)num_steps;
    double sum = 0.0;
    omp_set_num_threads(num_threads);

#pragma omp parallel
    {
        double x = 0.0;

#pragma omp for reduction(+:sum)
        for (int i = 0; i < num_steps; i++) {
            x = (i + 0.5)*step;
            sum += 4.0/(1.0 + x*x);
        }
    }
    pi = step * sum;

    return pi;
}

\end{lstlisting}
\selectlanguage{greek}

\selectlanguage{greek}

\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{ \emph{Καταγραφή χρόνων εκτέλεσης παραδειγμάτων}}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.35\textwidth} | p{0.35\textwidth}|}
 \textbf{Αριθμός Βημάτων\cellcolor[HTML]{D0D0D0}} & \textbf{Χρόνος Υπολογισμού (\emph{\en{sec}}) }\cellcolor[HTML]{D0D0D0} \\
\hline
 100000000 &  0.027 \\
\hline
 200000000 &  0.052 \\
\hline
 300000000 & 0.071 \\
\hline
 400000000 & 0.0901 \\
 \hline
\end{tabular}
\end{table}

\clearpage
\subsubsection{Παραλλαγή 5\textsuperscript{η}}
\subparagraph{}

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Αρχικοποίηση τιμών διανύσματος}} , frame=tlrb]{Name}
int main(int argc, char **argv) {
    Opts o;
    parseArgs(argc, argv, o);
    auto seconds = omp_get_wtime();
    double step = 1.0/(double)o.num_steps;
    double sum = 0.0;
    double p = 0.0;
#pragma omp parallel
    {
#pragma omp single
        sum = pi_comp(0, o.num_steps, step);
    }
    p = step * sum;

    std::cout << "Elapsed Time: " << omp_get_wtime() - seconds << std::endl;
    std::cout << "pi Value: " << p << std::endl;
    return 0;
}

\end{lstlisting}
\selectlanguage{greek}

\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{ \emph{Καταγραφή χρόνων εκτέλεσης παραδειγμάτων}}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.35\textwidth} | p{0.35\textwidth}|}
 \textbf{Αριθμός Βημάτων\cellcolor[HTML]{D0D0D0}} & \textbf{Χρόνος Υπολογισμού (\emph{\en{sec}}) }\cellcolor[HTML]{D0D0D0} \\
\hline
 100000000 & 0.379876 \\
\hline
 200000000 & 0.732152 \\
\hline
 300000000 & 1.06563 \\
\hline
 400000000 & 1.44172 \\
 \hline
\end{tabular}
\end{table}

\clearpage
\subsubsection{Παραλλαγή 6\textsuperscript{η}}
\subparagraph{}

\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Αρχικοποίηση τιμών διανύσματος}} , frame=tlrb]{Name}

#define MIN_BLK 10000000

double pi_comp(int Nstart, int Nfinish, double step) {
    double x = 0.0;
    double sum = 0.0, sum1 = 0.0, sum2 = 0.0;

    if (Nfinish - Nstart < MIN_BLK) {
        for (int i = Nstart; i < Nfinish; ++i) {
            x = (i + 0.5) * step;
            sum += 4.0/(1.0 + x*x);
        }
    } else {
        int iblk = Nfinish-Nstart;
#pragma omp task shared(sum1)
        sum1 = pi_comp(Nstart, Nfinish-iblk/2, step);
#pragma omp task shared(sum2)
        sum2 = pi_comp(Nfinish-iblk/2, Nfinish, step);
#pragma omp taskwait
        sum = sum1 + sum2;
    }

    return sum;
}

\end{lstlisting}
\selectlanguage{greek}

\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{ \emph{Καταγραφή χρόνων εκτέλεσης παραδειγμάτων}}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.35\textwidth} | p{0.35\textwidth}|}
 \textbf{Αριθμός Βημάτων\cellcolor[HTML]{D0D0D0}} & \textbf{Χρόνος Υπολογισμού (\emph{\en{sec}}) (\emph{\en{ MINBLK: 10000000}}) }\cellcolor[HTML]{D0D0D0} \\
\hline
 100000000 &  0.372117\\
\hline
 200000000 &   0.736442 \\
\hline
 300000000 &  1.09589\\
\hline
 400000000 &  1.46092\\
 \hline
 \end{tabular}
\end{table}

\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{ \emph{Καταγραφή χρόνων εκτέλεσης παραδειγμάτων}}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.35\textwidth} | p{0.35\textwidth}|}
 \textbf{Αριθμός Βημάτων\cellcolor[HTML]{D0D0D0}} & \textbf{Χρόνος Υπολογισμού (\emph{\en{sec}}) 
 (\en{\emph{MINBLK: 50000000}}) }\cellcolor[HTML]{D0D0D0} \\
\hline
 100000000 &  0.278347\\
\hline
 200000000 &   0.65436\\
\hline
 300000000 &   0.973535 \\
\hline
 400000000 &   1.45033 \\
  \hline
   \end{tabular}
\end{table}

\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{ \emph{Καταγραφή χρόνων εκτέλεσης παραδειγμάτων}}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.35\textwidth} | p{0.35\textwidth}|}
 \textbf{Αριθμός Βημάτων\cellcolor[HTML]{D0D0D0}} & \textbf{Χρόνος Υπολογισμού (\emph{\en{sec}}) (\en{\emph{MINBLK: 10000000}}) }\cellcolor[HTML]{D0D0D0} \\
\hline
 100000000 &  0.340634 \\
\hline
 200000000 &   0.600201\\
\hline
 300000000 &  1.05377  \\
\hline
 400000000 &   1.45176\\
 \hline
\end{tabular}
\end{table}

\clearpage
\subsubsection{Παραλλαγή 7\textsuperscript{η}}
\subparagraph{}
\selectlanguage{english}
\begin{lstlisting}[language=C++, caption={\el{Υπολογισμός $\pi$}} , frame=tlrb]{Name}
double pi(long num_steps) {
    double dH = 1.0/(double)num_steps;
    double dX = 0.0, dSum = 0.0;

#pragma omp target teams distribute map(tofrom: dSum),\
                                    map(to:dX,  dH, num_steps)\
                                    reduction(+:dSum)
    for (int i = 0; i < num_steps; i++) {
        dX = dH * ((double) i  + 0.5);
        dSum += (4.0 / (1.0 + dX * dX));
    } // End parallel for simd region

    return dH * dSum;
}

\end{lstlisting}
\selectlanguage{greek}

\begin{table}[htbp]
\centering
\captionsetup{justification=raggedright,
singlelinecheck=false
}
\caption{ \emph{Καταγραφή χρόνων εκτέλεσης παραδειγμάτων}}
\def\arraystretch{1.5}
\begin{tabular}{| p{0.35\textwidth} | p{0.35\textwidth}|}
 \textbf{Αριθμός Βημάτων\cellcolor[HTML]{D0D0D0}} & \textbf{Χρόνος Υπολογισμού (\emph{\en{sec}}) }\cellcolor[HTML]{D0D0D0} \\
\hline
 100000000 &  5.540  --> 3.10026  \\
\hline
 200000000 &  10.178 --> 3.09927 \\
\hline
 300000000 &  14.757 --> 3.09838 \\
\hline
 400000000 &  19.432 --> 3.09866 \\
 \hline
\end{tabular}
\end{table}

